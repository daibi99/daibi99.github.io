[{"title":"Data Structure－Graph","url":"/2022/04/08/Data%20Structure%20Graph/","content":"　　本文主要记录了数据结构——图相关的知识整理。\n一、图的基本术语图　　图是由有限非空的顶点集合与表示顶点之间关系的集合组成的，也就是顶点集V与边集E，我们将图G记作G = (V , E)。另外，我们用|V|表示图的顶点数，|E|表示图的边数。\n有向图　　顶点与顶点之间的连接（弧）是有向的，一般用从一个顶点指向另一个顶点的有序对来表示弧，例如有序对，其中ｖ,w是顶点，则就是代表从v到w的一条弧。举个简单的例子：G = (V,E) ;  V = { 1,2,3 }; E = {,,};\n无向图　　顶点与顶点之间的连接（边）是无向的，这时我们就用无序对来表示边，例如(v,w)就表示了顶点v与顶点w之间相关联。\n简单图　　简单图需要满足两个条件，一是不能有重复的边；二是不存在顶点到自身的边。\n完全图　　完全图要求任意两个顶点之间都存在边(或者弧)。对于无向图来说，|E|的取值范围为0—n(n-1)/2, 有n(n-1)/2条边的无向图就称作完全图。对于有向图，|E|的取值范围为0—n(n-1), 有n(n-1)条边的有向图就称作有向完全图。\n连通，连通图与连通分量　　连通是针对无向图而言的，若无向图中顶点v到顶点w有路径存在，我们就称v和w是连通的。若无向图任意两个顶点都是连通的，我们就称无向图G为连通图。无向图中的极大连通子图被称做连通分量。也就是说，若一个无向图有n个顶点，但是它的边数小于n-1，那么此图必是非连通图。若一个无向图有n个顶点，它是非连通图，那么它最多只能有(n-1)(n-2)/2条边。\n强连通图，强连通分量　　强连通是针对有向图而言的，若有向图中顶点v与顶点w，顶点w与顶点v均有路径存在，则这两个顶点就是强连通的。若有向图中每一对顶点都是强连通的，则称之为强连通图。也就是说n个顶点的有向图，至少要有n-1条弧才能成为强连通图。\n度　　在无向图中，顶点v的度是指依附于顶点v的边的条数，也就是说无向图的全部顶点的度总和等于边数的两倍，因为每条边都与两个顶点相关联。对于有向图，度分为出度与入度，出度是指从该顶点出发指向别的顶点的弧的数量，入度则是指指向该顶点的弧的数量。也就是说，有向图每个顶点的入度之和与出度之和都等于边数e。\n环　　若顶点之间的路径第一个顶点与最后一个顶点相同，则称该路径为环。若一个图有n个顶点，且大于n-1条边，则该图一定有环。\n二、图的存储邻接矩阵　　邻接矩阵是指用一个一维数组来存储顶点，用一个二维数组来存储顶点之间的关系。例如n个顶点的图就会构成一个A[n][n]的矩阵。若v[i]到v[j]之间有边，则A[i][j]的值就为1，否则为0。由此可知，图的邻接矩阵是唯一的，无向图的邻接矩阵是一个对称矩阵，且邻接矩阵适合存储稠密图，因为它的存储空间是由顶点个数决定的，空间复杂度为O(n^2)，若是稀疏图则没必要花费那么大的空间来存储边的关系。\n邻接表　　与邻接矩阵相比，邻接表就适合存储稀疏图。我们为图的每一个顶点创建一个单链表，并将该边指向的顶点插入到该链表中，因此，无向图的邻接表空间复杂度为O(|V|+2|E|)，有向图则为O(|V|+|E|)。邻接表并不唯一，因为每个顶点对应的单链表，各个顶点的链接次序是任意的。\n十字链表　　十字链表是针对有向图的链式存储结构。十字链表为有向图中每个顶点创建了一个节点，每条弧也创建了一个结点，弧结点除去信息有4个域: 尾域、头域、链域hlink指向弧头相同的下一条弧、链域tlink指向弧尾相同的下一条弧。顶点结点除去信息域还有firstin 和firtsout 两个域，分别指向以该顶点为弧头或弧尾的第一个弧结点。注意顶点之间是顺序存储的，十字链表之所以这么设计，是为了方便找到以V[i]为尾或者为头的弧，因而容易求顶点的入度和出度。十字链表不唯一，但一个十字链表表示确定一个图。\n邻接多重表　　邻接多重表是针对无向图的链式存储结构。因其查找顶点间是否连通以及删除操作效率较低，应用极少，不做叙述。\n三、图的遍历Breadth-First-Search(BFS)　　广度优先算法（BFS）算法的基本思想是，从给定顶点v开始，依次访问v的（还未被访问过的）邻接顶点w1、w2、w3…，然后从w1、w2、w3开始，重复上述的过程，直到所有的顶点都被访问，因此该算法需要借助一个辅助队列来记录正在访问顶点的下一层顶点。需要注意的是，每个顶点只能被访问一次。BFS在数据结构中可以用在Dijkstra单源最短路径算法和Prim最小生成树算法。BFS伪代码如下：bool visited[Max_v];      //标记访问数组void BFSTraversre(Graph G)&#123;\tfor（i = 0; i &lt; G.vexnum; i++)\t     visited[i] = false;          //初始化访问数组\tInitQueue(Q);            \tfor (i = 0; i &lt; G.vexnum; i++)\t\tif (!vsisted[i])\t\t\tBFS(G, i);      //若顶点未被访问过，则对其进行BFS&#125;void BFS(Graph G, int v)&#123;\tvisit(v);\tvisited[v] = true;             //标记为已访问 \tEnqueue(Q, V);                //v进队\twhile (!isEmpty(Q))\t&#123;\t\tDeQueue(Q, v);\t\tfor (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)    //v的邻接顶点入队\t\t&#123;\t\t\tif(!visited[w])\t\t\t\tvisit[w];\t\t\t\tvisited[w]=TRUE;\t\t\t\tEnQueue(Q,w);\t\t&#125;\t&#125;&#125;　　BFS算法需要借助辅助队列，而且每个顶点都需要入队一次，所以空间复杂度是O(|V|)。当图采用邻接表存储时，每个顶点需要被访问一次，而访问该顶点的邻接顶点只需要对单链表进行操作，因此时间复杂度为O(|V|+|E|)。当图采用邻接矩阵存储时，查找每个顶点的邻接顶点所需时间为O(|V|)，所以总时间复杂度为O(|V^2|)。\nDepth-First-Search(DFS)　　深度优先算法（DFS）的基本思想是，从给定顶点v出发，访问与v邻接的且未被访问过的顶点w，再从w出发，访问与w邻接且未被访问过的顶点w1，重复此过程，当不能再往下访问时，依次退回到最近被访问的顶点，若他还有邻接顶点未被访问过，则从该点开始继续上述过程，直到所有顶点被访问。因此，DFS算法需要借助递归工作栈来返回最近被访问顶点的值。DFS伪代码如下：bool visited[Max_v];      //标记访问数组void DFSTraversre(Graph G)&#123;\tfor（i = 0; i &lt; G.vexnum; i++)\tvisited[i] = false;          //初始化访问数组\tfor (i = 0; i &lt; G.vexnum; i++)\t\tif (!vsisted[i])\t\t\tDFS(G, i);      //若顶点未被访问过，则对其进行DFS&#125;void DFS(Graph G, int v)&#123;\tvisit(v);\tvisited[v] = TRUE;\tfor(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))\t\tif (!visited[w]) &#123;\t\t\tDFS(G, w)\t\t&#125;&#125;　　DFS算法需要用到递归工作栈，因此空间复杂度为O(|V|)。当图用邻接表存储时，查找所有顶点需要O(|V|+|E|)。当图用邻接矩阵存储时，每个顶点和其邻接结点的查找都需要O(|V|)，故总时间复杂度为O(|V^2|。\n四、遍历算法的应用及拓展连通性和路径查找　　遍历算法可以判断图的连通性。例如对于一个无向图，若图是连通的，则从任意顶点出发，仅需一次遍历就可以访问所有的结点。若图非连通，则只能访问到该图的连通分量的结点。　　上文中DFS算法使用了递归，那么非递归的DFS应该怎么设计呢？首先我们需要一个栈，用来存储访问过的结点信息，因为当我们不能再往下访问时，需要回退到最近访问的结点，这个特性刚好可以用栈来实现，我们在访问一个顶点时，要把它放进栈中，当栈非空时，将其取出，再将其邻接的结点放进去，重复上述过程。DFS非递归代码如下：bool visited[Max_v]; void DFSTraversre(Graph G)&#123;\tfor（i = 0; i &lt; G.vexnum; i++)\t          visited[i] = false;  \tInitStack(S);\tfor (i = 0; i &lt; G.vexnum; i++)\t\tif (!vsisted[i])\t\t\tDFS(G, i); &#125;void DFS(Graph G, int v)&#123;\tPush(S, v);\tvisited[v] = true;\twhile (!isEmpty(S))\t\ta = Pop(S);\t        visit[a];\t\tfor (w = NextNeighbor(G, a); w &gt;= 0; w = NextNeighbor(G, a, w)) &#123;\t\t\tif (!visited[w])\t\t\t\tPush(S, w);\t\t\t        visited[w] = true;\t\t&#125;&#125;　　遍历算法还可以应用到查找有向图中是否存在顶点v到顶点w的路径。下面分别用BFS与DFS算法演示：\n　　BFS:int BFS(Graph G, int v, int w)&#123;\tInitQueue(Q);\tEnqueue(Q, v);\twhile (!isEmpty(Q))\t\tDequeue(Q, u);            //u为队头元素\t        visited[u] = true;\t\tif (u == w)\t\t\treturn 1;\t\tfor (p = NextNeighbor(G, u); p &gt;= 0; p = NextNeighbor(G, u, p))\t\t&#123;\t\t\tif (p == w)         //p=w查找成功，返回1\t\t\t\treturn 1;\t\t\tif (!visited[p])    //否则入队\t\t\t\tEnQueue(Q, p);\t\t\t        visited[p] = 1;\t\t&#125;&#125;　　DFS:void DFS(Graph G, int v, int w, bool reach)&#123;\tif (v == w) \t&#123;\t\treach = true;\t\treturn;\t&#125;\tvisit[v] = true;\tfor (i = NextNeighbor(G, v); i &gt;= 0; i = NextNeighbor(G, v, i)) \t&#123;\t\tif (i == w) &#123;\t\t\treach = true;\t\t\treturn;\t\t&#125;\t\tDFS(G, i, w, reach);\t&#125;&#125;\nPrim/Kruskal最小生成树算法　　最小生成树是指包含该图所有顶点并且有着尽可能少的边的树。也就是说对于一个生成树，它的边数等于顶点数减一，如果去掉它的一条边，它会变成非连通图，增加一条边，它就形成一条回路。Prim算法与Kruskal算法都是基于贪心算法的策略。　　Prim算法的基本思想：创建一个空树，选取一个顶点归入树，这时树中就只有一个顶点，然后选取其邻接顶点中与之相连的边权值最小的顶点并入树T，这时T有两个顶点，这时再从其余顶点中选取与该T相连的权值最小的顶点归并到T中，直到所有顶点都在T中。因为每个顶点都至少需要访问与之相连权值最小顶点的顶点一次，故Prim算法的时间复杂度为O(|V^2|)，因此Prim算法更适合边稠密的图。　　Kruskal算法的基本思想：初始状态，将一个图视为只有顶点没有边的独立的连通分量，然后按照边的权值从小到大的排序，不断选择未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T，否则舍弃继续寻找下一条权值最小的边，直到所有顶点都在T中。该算法最大的开销在于边权值的排序，一般我们使用堆排序来解决，时间复杂度为O(|E|log2|E|)，因此Kruskal适合顶点多而边稀疏的图。\nDijkstra单源最短路径算法　　\nFloyd多源最短路径算法","categories":["Nonsense"]},{"title":"Fishing Master","url":"/2022/04/07/Finshing%20Master/","content":"　　This is a question from CCPC 2019, the problem is described as follows:\n　　Heard that daibi is a fishing MASTER, you want to acknowledge him as your mentor. As everybody knows, if you want to be a MASTER’s apprentice, you should pass the trial. So when you find fishing MASTER daibi, the trial is as follow: There are n fish in the pool. For the i - th fish, it takes at least ti minutes to stew(overcook is acceptable). To simplify this problem, the time spent catching a fish is k minutes. You can catch fish one at a time and because there is only one pot, only one fish can be stewed in the pot at a time.  While you are catching a fish, you can not put a raw fish you have caught into the pot, that means if you begin to catch a fish, you can’t stop until after k minutes; when you are not catching fish, you can take a cooked fish (stewed for no less than ti) out of the pot or put a raw fish into the pot, these two operations take no time. Note that if the fish stewed in the pot is not stewed for enough time, you cannot take it out, but you can go to catch another fish or just wait for a while doing nothing until it is sufficiently stewed.Now daibi wants you to catch and stew all the fish as soon as possible (you definitely know that a fish can be eaten only after sufficiently stewed), so that he can have a satisfying meal. If you can complete that in the shortest possible time, daibi will accept you as his apprentice and say “I am done! I am full!”. If you can’t, daibi will not accept you and say “You are done! You are fool!”. So what’s the shortest time to pass the trial if you arrange the time optimally?\nSolving Idea:　　Ideally, the time it takes res = m + the sum of the time to cook all the fish.But in some cases, we can’t just go fishing when we cook every fish, so we need to cook some fish for more time to catch some extra fish. What we have to do is to reduce the extra fish as much as possible. time spent. When we cook the ith fish, the number of fish we can fish without spending any extra time is a[i] / m, and the remaining time is a[i] % m, we can count whether we can fish without spending any extra time Time to catch all the fish, if not, we need to spend m - a[i] % m more time after the fish with the most time remaining is cooked.\nSolution:\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, n) for (int i = 1; i &lt;= n; ++i)const int N = 1E5 + 10;int a[N];int main()&#123;    int t; cin &gt;&gt; t;    while (t--) &#123;        vector&lt;int&gt; b;        int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        ll res = m; int cou = 1;         rep(i, n) scanf(&quot;%d&quot;, &amp;a[i]), res += a[i], cou += a[i] / m, b.push_back(a[i] % m);        sort(b.begin(), b.end(), greater&lt;int&gt;());        for (int i = 1; i &lt;= n - cou; ++i) res += m - b[i - 1];        cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;\n","categories":["Algorithm Practice"]},{"title":"Divide-and-Conquer Monte Carlo Tree Search For Goal-Directed Planning","url":"/2022/04/07/Monte%20Carlo%20Tree/","content":"　　This paper is published by  Giambattista Parascandolo, Lars Buesing, Josh Merel and so on. You can find this paper on https://arxiv.org/abs/2004.11410.\n","categories":["Paper Summary"]}]