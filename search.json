[{"title":"Fishing Master","url":"/2022/04/07/Finshing%20Master/","content":"　　This is a question from CCPC 2019, the problem is described as follows:\n　　Heard that daibi is a fishing MASTER, you want to acknowledge him as your mentor. As everybody knows, if you want to be a MASTER’s apprentice, you should pass the trial. So when you find fishing MASTER daibi, the trial is as follow: There are n fish in the pool. For the i - th fish, it takes at least ti minutes to stew(overcook is acceptable). To simplify this problem, the time spent catching a fish is k minutes. You can catch fish one at a time and because there is only one pot, only one fish can be stewed in the pot at a time.  While you are catching a fish, you can not put a raw fish you have caught into the pot, that means if you begin to catch a fish, you can’t stop until after k minutes; when you are not catching fish, you can take a cooked fish (stewed for no less than ti) out of the pot or put a raw fish into the pot, these two operations take no time. Note that if the fish stewed in the pot is not stewed for enough time, you cannot take it out, but you can go to catch another fish or just wait for a while doing nothing until it is sufficiently stewed.Now daibi wants you to catch and stew all the fish as soon as possible (you definitely know that a fish can be eaten only after sufficiently stewed), so that he can have a satisfying meal. If you can complete that in the shortest possible time, daibi will accept you as his apprentice and say “I am done! I am full!”. If you can’t, daibi will not accept you and say “You are done! You are fool!”. So what’s the shortest time to pass the trial if you arrange the time optimally?\nSolving Idea:　　Ideally, the time it takes res = m + the sum of the time to cook all the fish.But in some cases, we can’t just go fishing when we cook every fish, so we need to cook some fish for more time to catch some extra fish. What we have to do is to reduce the extra fish as much as possible. time spent. When we cook the ith fish, the number of fish we can fish without spending any extra time is a[i] / m, and the remaining time is a[i] % m, we can count whether we can fish without spending any extra time Time to catch all the fish, if not, we need to spend m - a[i] % m more time after the fish with the most time remaining is cooked.\nSolution:\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 1; i &lt;= n; ++i)\nconst int N = 1E5 + 10;\nint a[N];\nint main()\n    &#123;\n        int t; cin &gt;&gt; t;\n        while (t--) &#123;\n            vector&lt;int&gt; b;\n            int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n            ll res = m; int cou = 1; \n            rep(i, n) scanf(&quot;%d&quot;, &amp;a[i]), res += a[i], cou += a[i] / m, b.push_back(a[i] % m);\n            sort(b.begin(), b.end(), greater&lt;int&gt;());\n            for (int i = 1; i &lt;= n - cou; ++i) res += m - b[i - 1];\n            cout &lt;&lt; res &lt;&lt; endl;\n        &#125;\n        return 0;\n    &#125;\n","categories":["Algorithm Practice"]},{"title":"Data structure - Sort","url":"/2022/04/10/Data%20Structure%20Sort/","content":"　　本文主要做了数据结构——排序的知识整理。\n一、插入排序　　插入排序的基本思想是每次将一个待排序的记录按其大小插入到前面已排好序的子序列，直到全部记录插入完成。由此思想引申出三种插入排序算法：直接插入排序、折半插入排序和希尔排序。\n直接插入排序　　直接插入排序是最简单也是最直观的。我们要将元素E[i]插入到已有序的子序列E[1…i-1]，首先要在E[1…i-1]中按照元素大小找到元素E[i]插入的位置k，之后将E[k…i-1]中的所有元素后移一个位置，再将E[i]插入到E[k]。下面是直接插入排序的代码：\nvoid InsertSort(ElemType A[], int n)         //给定n个元素的数组进行排序\n&#123;\n    int i, j;\n    for (i = 2; i &lt;= n; i++)\n    &#123;\n        if (A[i] &lt; A[i - 1])\n        &#123;\n            A[0] = A[i];\n            for (j = i - 1; A[0] &lt; A[j]; --j)   //这里的--j是先自减，再赋值，也就是说该for循环中的j为1, 但循环结束之后, j的值为0。\n                A[j + 1] = A[j];\n            A[j + 1] = A[0];\n        &#125;\n    &#125;\n&#125;\n　　性能分析：直接插入排序使用了常数个辅助单元，所以空间复杂度为O(1)。最好情况下，给定的元素本就是有序的，因此在排序过程中只需要比较元素而不用移动元素，因此时间复杂度为O(n)。最坏情况下，给定的元素为逆序，每次插入不仅需要比较次数最大，而且需要移动的次数也是最大的，平均情况下，取最好与最坏情况的平均值为n^2/4。因此直接插入排序算法的时间复杂的是O(n^2)。由于每次插入元素时总是向前比较再移动，所以不会出现相同元素相对位置改变的情况，因此直接插入排序是一个稳定的排序方法。\n折半插入排序　　折半插入排序的基本思想是\n","categories":["Nonsense"]},{"title":"Data Structure－Graph","url":"/2022/04/08/Data%20Structure%20Graph/","content":"　　本文主要做了数据结构——图相关的知识整理。\n一、图的基本术语图　　图是由有限非空的顶点集合与表示顶点之间关系的集合组成的，也就是顶点集V与边集E，我们将图G记作G = (V , E)。另外，我们用|V|表示图的顶点数，|E|表示图的边数。\n有向图　　顶点与顶点之间的连接（弧）是有向的，一般用从一个顶点指向另一个顶点的有序对来表示弧，例如有序对，其中ｖ,w是顶点，则就是代表从v到w的一条弧。举个简单的例子：G = (V,E) ;  V = { 1,2,3 }; E = {&lt;1,2&gt;,&lt;2,3&gt;,&lt;1,3&gt;};\n无向图　　顶点与顶点之间的连接（边）是无向的，这时我们就用无序对来表示边，例如(v,w)就表示了顶点v与顶点w之间相关联。\n简单图　　简单图需要满足两个条件，一是不能有重复的边；二是不存在顶点到自身的边。\n完全图　　完全图要求任意两个顶点之间都存在边(或者弧)。对于无向图来说，|E|的取值范围为0—n(n-1)/2, 有n(n-1)/2条边的无向图就称作完全图。对于有向图，|E|的取值范围为0—n(n-1), 有n(n-1)条边的有向图就称作有向完全图。\n连通，连通图与连通分量　　连通是针对无向图而言的，若无向图中顶点v到顶点w有路径存在，我们就称v和w是连通的。若无向图任意两个顶点都是连通的，我们就称无向图G为连通图。无向图中的极大连通子图被称做连通分量。也就是说，若一个无向图有n个顶点，但是它的边数小于n-1，那么此图必是非连通图。若一个无向图有n个顶点，它是非连通图，那么它最多只能有(n-1)(n-2)/2条边。\n强连通图，强连通分量　　强连通是针对有向图而言的，若有向图中顶点v与顶点w，顶点w与顶点v均有路径存在，则这两个顶点就是强连通的。若有向图中每一对顶点都是强连通的，则称之为强连通图。也就是说n个顶点的有向图，至少要有n-1条弧才能成为强连通图。\n度　　在无向图中，顶点v的度是指依附于顶点v的边的条数，也就是说无向图的全部顶点的度总和等于边数的两倍，因为每条边都与两个顶点相关联。对于有向图，度分为出度与入度，出度是指从该顶点出发指向别的顶点的弧的数量，入度则是指指向该顶点的弧的数量。也就是说，有向图每个顶点的入度之和与出度之和都等于边数e。\n环　　若顶点之间的路径第一个顶点与最后一个顶点相同，则称该路径为环。若一个图有n个顶点，且大于n-1条边，则该图一定有环。\n二、图的存储邻接矩阵　　邻接矩阵是指用一个一维数组来存储顶点，用一个二维数组来存储顶点之间的关系。例如n个顶点的图就会构成一个A_{n \\times n}的矩阵。若v_i到v_j之间有边，则A_{ij}的值就为1，否则为0。由此可知，图的邻接矩阵是唯一的，无向图的邻接矩阵是一个对称矩阵，且邻接矩阵适合存储稠密图，因为它的存储空间是由顶点个数决定的，空间复杂度为O(n^2)，若是稀疏图则没必要花费那么大的空间来存储边的关系。\n邻接表　　与邻接矩阵相比，邻接表就适合存储稀疏图。我们为图的每一个顶点创建一个单链表，并将该边指向的顶点插入到该链表中，因此，无向图的邻接表空间复杂度为O(|V|+2|E|)，有向图则为O(|V|+|E|)。邻接表并不唯一，因为每个顶点对应的单链表，各个顶点的链接次序是任意的。\n十字链表　　十字链表是针对有向图的链式存储结构。十字链表为有向图中每个顶点创建了一个节点，每条弧也创建了一个结点，弧结点除去信息有4个域: 尾域、头域、链域hlink指向弧头相同的下一条弧、链域tlink指向弧尾相同的下一条弧。顶点结点除去信息域还有firstin 和firtsout 两个域，分别指向以该顶点为弧头或弧尾的第一个弧结点。注意顶点之间是顺序存储的，十字链表之所以这么设计，是为了方便找到以v_i为尾或者为头的弧，因而容易求顶点的入度和出度。十字链表不唯一，但一个十字链表表示确定一个图。\n邻接多重表　　邻接多重表是针对无向图的链式存储结构。因其查找顶点间是否连通以及删除操作效率较低，应用极少，不做叙述。\n三、图的遍历Breadth-First-Search(BFS)　　广度优先算法（BFS）算法的基本思想是，从给定顶点v开始，依次访问v的（还未被访问过的）邻接顶点w_1、w_2、w_3…，然后从w_1、w_2、w_3开始，重复上述的过程，直到所有的顶点都被访问，因此该算法需要借助一个辅助队列来记录正在访问顶点的下一层顶点。需要注意的是，每个顶点只能被访问一次。BFS在数据结构中可以用在Dijkstra单源最短路径算法和Prim最小生成树算法。BFS伪代码如下：\nbool visited[Max_v];      //标记访问数组\nvoid BFSTraversre(Graph G)\n{\n    for（i = 0; i &lt; G.vexnum; i++)\n         visited[i] = false;          //初始化访问数组\n    InitQueue(Q);            \n    for (i = 0; i &lt; G.vexnum; i++)\n        if (!vsisted[i])\n            BFS(G, i);      //若顶点未被访问过，则对其进行BFS\n}\n\nvoid BFS(Graph G, int v)\n{\n    visit(v);\n    visited[v] = true;             //标记为已访问 \n    Enqueue(Q, V);                //v进队\n    while (!isEmpty(Q))\n    {\n        DeQueue(Q, v);\n        for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)    //v的邻接顶点入队\n        {\n            if(!visited[w])\n                visit[w];\n                visited[w]=TRUE;\n                EnQueue(Q,w);\n        }\n    }\n}\n　　BFS算法需要借助辅助队列，而且每个顶点都需要入队一次，所以空间复杂度是O(|V|)。当图采用邻接表存储时，每个顶点需要被访问一次，而访问该顶点的邻接顶点只需要对单链表进行操作，因此时间复杂度为O(|V|+|E|)。当图采用邻接矩阵存储时，查找每个顶点的邻接顶点所需时间为O(|V|)，所以总时间复杂度为O(|V^2|)。\nDepth-First-Search(DFS)　　深度优先算法（DFS）的基本思想是，从给定顶点v出发，访问与v邻接的且未被访问过的顶点w，再从w出发，访问与w邻接且未被访问过的顶点w_1，重复此过程，当不能再往下访问时，依次退回到最近被访问的顶点，若他还有邻接顶点未被访问过，则从该点开始继续上述过程，直到所有顶点被访问。因此，DFS算法需要借助递归工作栈来返回最近被访问顶点的值。DFS伪代码如下：\nbool visited[Max_v];      //标记访问数组\nvoid DFSTraversre(Graph G)\n{\n    for（i = 0; i &lt; G.vexnum; i++)\n    visited[i] = false;          //初始化访问数组\n    for (i = 0; i &lt; G.vexnum; i++)\n        if (!vsisted[i])\n            DFS(G, i);      //若顶点未被访问过，则对其进行DFS\n}\n\nvoid DFS(Graph G, int v)\n{\n    visit(v);\n    visited[v] = TRUE;\n    for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))\n        if (!visited[w]) {\n            DFS(G, w)\n        }\n}\n　　DFS算法需要用到递归工作栈，因此空间复杂度为O(|V|)。当图用邻接表存储时，查找所有顶点需要O(|V|+|E|)。当图用邻接矩阵存储时，每个顶点和其邻接结点的查找都需要O(|V|)，故总时间复杂度为O(|V^2|)。\n四、遍历算法的应用及拓展连通性和路径查找　　遍历算法可以判断图的连通性。例如对于一个无向图，若图是连通的，则从任意顶点出发，仅需一次遍历就可以访问所有的结点。若图非连通，则只能访问到该图的连通分量的结点。　　上文中DFS算法使用了递归，那么非递归的DFS应该怎么设计呢？首先我们需要一个栈，用来存储访问过的结点信息，因为当我们不能再往下访问时，需要回退到最近访问的结点，这个特性刚好可以用栈来实现，我们在访问一个顶点时，要把它放进栈中，当栈非空时，将其取出，再将其邻接的结点放进去，重复上述过程。DFS非递归代码如下：\nbool visited[Max_v]; \nvoid DFSTraversre(Graph G)\n{\n    for（i = 0; i &lt; G.vexnum; i++)\n              visited[i] = false;  \n    InitStack(S);\n    for (i = 0; i &lt; G.vexnum; i++)\n        if (!vsisted[i])\n            DFS(G, i); \n}\n\nvoid DFS(Graph G, int v)\n{\n    Push(S, v);\n    visited[v] = true;\n    while (!isEmpty(S))\n        a = Pop(S);\n            visit[a];\n        for (w = NextNeighbor(G, a); w &gt;= 0; w = NextNeighbor(G, a, w)) {\n            if (!visited[w])\n                Push(S, w);\n                    visited[w] = true;\n        }\n}\n　　遍历算法还可以应用到查找有向图中是否存在顶点v到顶点w的路径。下面分别用BFS与DFS算法演示：\n　　BFS:\nint BFS(Graph G, int v, int w)\n{\n    InitQueue(Q);\n    Enqueue(Q, v);\n    while (!isEmpty(Q))\n        Dequeue(Q, u);            //u为队头元素\n            visited[u] = true;\n        if (u == w)\n            return 1;\n        for (p = NextNeighbor(G, u); p &gt;= 0; p = NextNeighbor(G, u, p))\n        {\n            if (p == w)         //p=w查找成功，返回1\n                return 1;\n            if (!visited[p])    //否则入队\n                EnQueue(Q, p);\n                    visited[p] = 1;\n        }\n}\n　　DFS:\nvoid DFS(Graph G, int v, int w, bool reach)\n{\n    if (v == w) \n    {\n        reach = true;\n        return;\n    }\n    visit[v] = true;\n    for (i = NextNeighbor(G, v); i &gt;= 0; i = NextNeighbor(G, v, i)) \n    {\n        if (i == w) {\n            reach = true;\n            return;\n        }\n        DFS(G, i, w, reach);\n    }\n}\nPrim/Kruskal最小生成树算法　　最小生成树是指包含该图所有顶点并且有着尽可能少的边的树。也就是说对于一个生成树，它的边数等于顶点数减一，如果去掉它的一条边，它会变成非连通图，增加一条边，它就形成一条回路。Prim算法与Kruskal算法都是基于贪心算法的策略。　　Prim算法的基本思想：创建一个空树，选取一个顶点归入树，这时树中就只有一个顶点，然后选取其邻接顶点中与之相连的边权值最小的顶点并入树T，这时T有两个顶点，这时再从其余顶点中选取与该T相连的权值最小的顶点归并到T中，直到所有顶点都在T中。因为每个顶点都至少需要访问与之相连权值最小顶点的顶点一次，故Prim算法的时间复杂度为O(|V^2|)，因此Prim算法更适合边稠密的图。　　Kruskal算法的基本思想：初始状态，将一个图视为只有顶点没有边的独立的连通分量，然后按照边的权值从小到大的排序，不断选择未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T，否则舍弃继续寻找下一条权值最小的边，直到所有顶点都在T中。该算法最大的开销在于边权值的排序，一般我们使用堆排序来解决，时间复杂度为O(|E|\\log_2 {|E|})，因此Kruskal适合顶点多而边稀疏的图。\nDijkstra单源最短路径算法　　之前介绍遍历的应用中可以查找路径，但那是对于无权图而言，而对于带权图（边有权值，可以想象为距离），我们常常需要寻找带权路径长度最短的那一条路径，并称之为最短路径。　　算法思想：Dijkstra算法设置一个集合来记录已求得最短路径的顶点，初始时把源点v0放入S，每次并入一个新顶点vi时，都要修改源点v0到集合S中其余顶点的当前最短路径值。这里设置了两个辅助数组dist[]和path[]，dist[]用来记录v0到其他顶点的当前最短路径长度，初态，若源点v_0到v_i有弧，则dist[i]为弧的权值，否则dist[i]为无穷大。path[i]用来记录原点到顶点i之间的最短路径的前驱结点，算法结束后可以追溯到v_0到v_i的最短路径。　　初始化集合S为{0}，dist[i]=arcs[0][i]，下一步，我们要选出满足dist[j]=Min{dist[i]}的顶点J，也就是选出与v0相连的所有顶点中，带权路径长度最短的那一条，并将其并入集合S，另外，还要修改v0到S（顶点vj并入之后）内其余顶点的路径长度。重复此过程，直到所有顶点并入S。该算法不适用于有权值为负的边，其时间复杂度为O(|V^2|)。\nFloyd多源最短路径算法　　算法思想：Floyd算法递推产生一个n阶方阵序列从A^{-1}，A^0...A^{n-1},其中方阵A用来记录顶点之间的路径长度，而上标k=-1，0，n-1指的是顶点之间绕行k个顶点的路径长度。也就是说，在初始状态，若顶点之间有路径，则在方阵中记录路径长度，若无路径，则记录无穷大，之后再来探究顶点之间若是绕行另一个顶点，会不会有路径或者原本的路径减小，此时就要在方阵中进行更新。Floyd算法的时间复杂度为O(|V^3|)。其实用Dijkstra算法轮流将每个顶点作为源点，并在所有边权值为负时运行一次，也可以解决每对顶点之间的最短路径问题。\n拓扑排序　　当图用来代表工程活动，顶点表示活动，我们用有向边&lt;v_i，v_j&gt;代表v_i必须先于v_j活动的关系，并将这种图记为AOV网。我们构建拓扑排序的步骤一般是：首先从AOV网选择一个没有前驱的顶点并输出，然后从网中删除该顶点以及以它为起点的有向边，重复上述步骤直到当前AOV网为空。\n关键路径　　与AOV网相似，AOE网是指整个图中仅有一个入度为0的顶点，称为源点，仅有一个出度为0的顶点，称为汇点。在AOE网上，有些活动是可以并行进行的，从源点到汇点的路径可能有很多条，并且这些路径的长度可能不同。完成所有路径上活动所需的时间可能不同，但所有路径上的活动都已经完成，整个工程才算结束。因此我们将从源点到汇点的所有路径中，具有最大路径长度的路径成为关键路径。　　求解关键路径的步骤如下：从源点出发，拓扑排序求其余顶点的最早发生时间v_e；之后从汇点出发，按逆拓扑排序求其余顶点的最迟发生时间v_l。根据v_e和v_l的值分别计算出所有弧的最早开始时间e和最迟开始时间l。若e-l=0，则这个弧就是关键路径中的弧。\n","categories":["Nonsense"]},{"title":"Divide-and-Conquer Monte Carlo Tree Search For Goal-Directed Planning","url":"/2022/04/07/Monte%20Carlo%20Tree/","content":"　　This paper is published by  Giambattista Parascandolo, Lars Buesing, Josh Merel and so on. You can find this paper on https://arxiv.org/abs/2004.11410.\n","categories":["Paper Summary"]}]